+++
title = "Goroutine"
date =  2022-11-11T10:54:49+08:00
description= "description"
weight = 4
+++

- [前言](#前言)
- [Go调度器模型(G-P-M 模型)](#go调度器模型g-p-m-模型)
- [调度方式](#调度方式)
  - [G被抢占调用调度](#g被抢占调用调度)
  - [channel阻塞或网络I/O下的调度](#channel阻塞或网络io下的调度)
  - [系统调用阻塞情况下，如何调度](#系统调用阻塞情况下如何调度)
- [协程控制](#协程控制)
- [协程池](#协程池)


## 前言

背景：

- 我们使用线程的代价要比进程小很多，但是依然不能大量创建线程，除了每个线程占用的资源不小之外，操作系统调度切换线程的代价也很大。
- 很多服务端程序，由于不能大量创建线程，只能选择在少量线程里做网络多路复用的方案（epoll/kqueue/IoCompletionPort这种机制），或者你会说可以用libevent和libev啊，这样的写法存在大量的钩子回调，给开发人员带来不小的负担。

看到上面的痛点，Go采用了Goroutine来解决这些痛点。Goroutine占用资源非常小，每个Gorouine栈的大小默认是2k字节。goroutine调度的切换也不用在操作系统内核中完成，代价很低。所以一个Go程序可以创建成千上万个并发的goroutine，而把这些goroutine按照一定算法放到cpu上执行的程序，我们就成为goroutine调度器（Scheduler）。

一个Go程序运行起来，在操作系统看来就是一个用户程序，操作系统的概念，只有线程，它甚至不知道有Goroutine的存在。Goroutine的调度完全靠GO自己完成。实现GO程序内Goroutine之间的公平竞争CPU的资源，这个任务就靠GO运行时（runtime）了，一个Go程序中，除了用户层代码，其他就是go运行时了。

## Go调度器模型(G-P-M 模型)

G、P、M这三个结构体定义都是很繁重的，每个结构体定义都包含十几甚至二、三十个字段。像调度器这样的核心代码都是非常复杂的，考虑的因素也很多。简单说明一下：

- G: 它是Goroutine，存储了Goroutine的执行栈信息、Goroutine状态以及Goroutine的任务函数等（G是可以重用的）。
- P: 它是逻辑Processor,P的数量决定了系统内最大可并行的G的数据（物理CPU核数>=P的数量）；P最大的作用是它有各种G对象队列、链表、缓存和状态。
- M: 它是真正执行计算的资源。在绑定有效的P后，一个调度循环开始；而调度循环的机制是从各种队列、P的本地运行队列中获取G,切换到G的执行栈上并行执行G的函数，调用goexit做清理工作，然后回到M。这样反复。M并不保存G的状态，这是G可以跨M调度的基础。


## 调度方式

### G被抢占调用调度

操作系统是按时间片调度线程的，Go并没有时间片的概念。如果某个G没有进行系统调用、没有I/O操作、没有阻塞在一个channel上，那么M是怎么让G停下来并调度下一个可运行的G?
这就要说抢占调度了。

除非是无限死循环，否则只要G调用函数，Go运行时就有了抢占G的机会。GO程序启动的时候，运行时会启动一个名为sysmon的M（你可以简单理解为监控器或监控协程），该M特殊之处就是其无需绑定P即可运行（以g0的形式），该M在整个Go程序的运行过程中非常重要。

### channel阻塞或网络I/O下的调度

如果G被阻塞在某个channel操作或者网络I/O操作上的时候，G会被放入到某个等待队列中，而M会尝试运行P的下一个可运行的G；如果此时P没有可运行的G给M运行，那么M将解绑P，并进入挂起状态。当I/O或者channel操作完成，在等待队列中的G会被唤醒，标记为可运行，并被放入到某个P队列中，绑定一个M后继续运行。

### 系统调用阻塞情况下，如何调度

如果G被阻塞在某个系统调用上，那么不仅仅G会阻塞，执行G的M也会解绑P，与G一起进入挂起状态。


## 协程控制

- 使用runtime.GOMAXPROCS(num int)可以设置线程数目。该值默认为CPU逻辑核数，如果设的太大，会引起频繁的线程切换，降低性能。
- runtime.Gosched()，用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次某个时候从该位置恢复执行。
- runtime.Goexit()，调用此函数会立即使当前的goroutine的运行终止（终止协程），而其它的goroutine并不会受此影响。runtime.Goexit在终止当前goroutine前会先执行此goroutine的还未执行的defer语句。请注意千万别在主函数调用runtime.Goexit，因为会引发panic。

## 协程池

